mapa_ind_tree <- read.csv2("Data_pasaporte.csv")
rownames(mapa_ind_tree) <- mapa_ind_tree$CODIGO.DE.ACCESIÓN
mapa_ind_tree
## Create complete genind object
MASHUA <- adegenet::genind_object(my_genlight, metadata = mapa_ind_tree)
id_gen <- indNames(my_genlight)   # nombres de individuos en genlight
id_gen
indNames(my_genlight)
data
## Convert genepop data to complete genind data
my_genlight <- new("genlight", matriz_pa_size)
matriz_pa_size
data_markers
# Matriz solo por tamaño (ignorando grosor):
matriz_pa_size <- data_markers %>%
filter(!is.na(marcador_probable), !is.na(Accesion)) %>%
mutate(valor = 1L) %>%
select(Accesion, marcador_probable, valor) %>%
distinct(Accesion, marcador_probable, .keep_all = TRUE) %>%
pivot_wider(
id_cols    = Accesion,
names_from = marcador_probable,
values_from = valor,
values_fill = 0L,
values_fn  = max
) %>%
arrange(Accesion)
matriz_pa_size
## Convert genepop data to complete genind data
my_genlight <- new("genlight", matriz_pa_size)
warnings()
row.names(matriz_pa_size) <- matriz_pa_size$Accesion
matriz_pa_size
matriz_pa_size <- as.data.frame(matriz_pa_size)
row.names(matriz_pa_size) <- matriz_pa_size$Accesion
matriz_pa_size
## Convert genepop data to complete genind data
my_genlight <- new("genlight", matriz_pa_size)
warnings()
matriz_pa_size
my_genlight
View(my_genlight)
## Load and set up metadata
mapa_ind_tree <- read.csv2("Data_pasaporte.csv")
rownames(mapa_ind_tree) <- mapa_ind_tree$CODIGO.DE.ACCESIÓN
id_gen <- indNames(my_genlight)   # nombres de individuos en genlight
id_meta <- mapa_ind_tree$ID       # columna con IDs en tu CSV
id_gen
id_meta
id_meta <- mapa_ind_tree$CODIGO.DE.ACCESIÓN       # columna con IDs en tu CSV
id_gen
id_meta
## Create complete genind object
MASHUA <- adegenet::genind_object(my_genlight, metadata = mapa_ind_tree)
## Create complete genind object
MASHUA <- adegenet::as.genind(my_genlight, metadata = mapa_ind_tree)
## Create complete genind object
MASHUA <- as.genind(my_genlight)
## Create complete genind object
MASHUA <- as.genind(my_genlight)
my_genlight
matriz_pa_size
View(matriz_pa_size)
## Convert genepop data to complete genind data
my_genlight <- df2genlight(data,
ploidy = 2,   # o 1 si son haploides
ncode  = 1)   # 1 dígito por alelo (0,1,2)
## Convert genepop data to complete genind data
my_genlight <- adegenet::df2genind(data,
ploidy = 2,   # o 1 si son haploides
ncode  = 1)   # 1 dígito por alelo (0,1,2)
## Convert genepop data to complete genind data
my_genlight <- adegenet::df2genind(matriz_pa_size,
ploidy = 2,   # o 1 si son haploides
ncode  = 1)   # 1 dígito por alelo (0,1,2)
my_genlight
## Load and set up metadata
mapa_ind_tree <- read.csv2("Data_pasaporte.csv")
rownames(mapa_ind_tree) <- mapa_ind_tree$CODIGO.DE.ACCESIÓN
id_gen <- indNames(my_genlight)   # nombres de individuos en genlight
id_meta <- mapa_ind_tree$CODIGO.DE.ACCESIÓN       # columna con IDs en tu CSV
pop(my_genind) <- mapa_ind_tree$PROVINCIA
pop(my_genlight) <- mapa_ind_tree$PROVINCIA
mapa_ind_tree
mapa_ind_tmp <- mapa_ind_tree %>% filter(CODIGO.DE.ACCESIÓN %in% matriz_pa_size$Accesion)
pop(my_genlight) <- mapa_ind_tmp$PROVINCIA
my_genlight
allelic_richness <- function(CAMU, table){
richAl <- t(as.matrix(allelic.richness(genind2hierfstat(CAMU))$Ar))
richAl <- richAl[order(row.names(richAl)),]
pop(CAMU) <- table$ID
richAl_core <- t(as.matrix(allelic.richness(genind2hierfstat(CAMU))$Ar))
richAl <- rbind(richAl, richAl_core[2,])
rownames(richAl)[9] <- "Core collection"
heatmap_alric <- pheatmap(richAl, cluster_rows = T, cluster_cols = F, treeheight_row = 80)
return(heatmap_alric)
}
## DAPC plot
mfd <- dapc_plots(MASHUA = my_genlight, mapa_ind_tree = mapa_ind_tmp, core = core, palette = my_pal)
## DAPC plot
mfd <- adegenet::compoplot.dapc(MASHUA = my_genlight, mapa_ind_tree = mapa_ind_tmp, core = core, palette = my_pal)
richAl <- t(as.matrix(allelic.richness(genind2hierfstat(my_genlight))$Ar))
genind2hierfstat(my_genlight)
my_genlight
library(adegenet)
library(hierfstat)
library(poppr)
library(pegas)   #
MASHUA <- my_genlight
sum_MASHUA <- summary(MASHUA)
sum_MASHUA
# Número de individuos, loci y poblaciones
n_ind <- nInd(MASHUA)
n_loc <- nLoc(MASHUA)
pops  <- levels(pop(MASHUA))
pops
n_ind; n_loc; pops
# Para mirar el resumen completo:
sum_MASHUA
## Convertir genind -> hierfstat
mashua_hier <- genind2hierfstat(MASHUA)
## Estadísticas básicas por locus y población
basic <- basic.stats(mashua_hier)
isrr5_1_18 <- readxl::read_excel("Data/EXCEL_I5-1AL18.xlsx")
View(isrr5_1_18)
# Limpiar Base.Pairs..bp. (quitar comas, pasar a numérico y redondear)
isrr5_1_18 <- isrr5_1_18 %>%
mutate(
Size_pb = Size_pb %>%
as.character() %>%
str_replace_all(",", "") %>%
as.numeric() %>%
round(0),
Banda_tamanho = as.numeric(Banda_tamanho )    # por si viene como factor/char
)
library(tidyverse)
# Limpiar Base.Pairs..bp. (quitar comas, pasar a numérico y redondear)
isrr5_1_18 <- isrr5_1_18 %>%
mutate(
Size_pb = Size_pb %>%
as.character() %>%
str_replace_all(",", "") %>%
as.numeric() %>%
round(0),
Banda_tamanho = as.numeric(Banda_tamanho )    # por si viene como factor/char
)
View(isrr5_1_18)
# Nos quedamos con columnas relevantes y quitamos las escaleras
data <- isrr5_1_18 %>%
select(Lane,Accesion,Size_pb, Banda, Banda_tamanho) %>%
filter(!(Lane %in% c(1, 10, 21))) %>%   # quitar escaleras
drop_na(Banda)
View(data)
View(data)
View(isrr5_1_18)
View(data)
# x: vector numérico de tamaños (bp)
# gap_thr: diferencia mínima (en bp) para considerar que hay un cambio de grupo
find_breaks <- function(x, gap_thr = 40) {
xs   <- sort(na.omit(x))
gaps <- diff(xs)
# puntos donde el "salto" es grande
idx_big_gap <- which(gaps > gap_thr)
# punto medio entre los dos valores que forman el hueco
cut_points <- xs[idx_big_gap] + gaps[idx_big_gap] / 2
# extremos del rango + un pequeño margen
breaks <- c(min(xs) - 1, cut_points, max(xs) + 1)
breaks
}
# Puedes ajustar gap_thr según lo cerrado/abierto que quieras los grupos
breaks  <- find_breaks(data$Size_pb, gap_thr = 10)
centers <- (head(breaks, -1) + tail(breaks, -1)) / 2
# etiquetas de marcador, por ejemplo: M1_1576, M2_972, ...
labels <- paste0("ISSR5", "_", round(centers))
data_markers <- data %>%
mutate(
marcador_probable = cut(
Size_pb,
breaks = breaks,
labels = labels,
include.lowest = TRUE
)
) %>%
# Clasificamos grosor relativo dentro de cada marcador:
# a = banda gruesa (>= mediana de grosor)
# b = banda delgada (< mediana de grosor)
group_by(marcador_probable) %>%
mutate(
umbral_grosor = median(Banda_tamanho, na.rm = TRUE),
tipo_banda    = if_else(Banda_tamanho >= umbral_grosor, "a", "b")
) %>%
ungroup() %>%
mutate(
marcador_ab = paste0(as.character(marcador_probable), "_", tipo_banda)
)
ggplot(data_markers, aes(x = Size_pb)) +
geom_histogram(bins = 60, fill = "grey70") +
geom_vline(xintercept = centers, linetype = 2) +
labs(x = "Base pairs (bp)", y = "Frecuencia") +
theme_minimal()
matriz_pa_ab <- data_markers %>%
filter(!is.na(marcador_ab), !is.na(Lane)) %>%
mutate(valor = 1L) %>%
select(Lane, marcador_ab, valor) %>%
distinct(Lane, marcador_ab, .keep_all = TRUE) %>%  # evitar duplicados exactos
pivot_wider(
id_cols    = Lane,
names_from = marcador_ab,
values_from = valor,
values_fill = 0L,
values_fn  = max   # 0 = ausencia, 1 = presente
) %>%
arrange(Lane)
# Matriz solo por tamaño (ignorando grosor):
matriz_pa_size <- data_markers %>%
filter(!is.na(marcador_probable), !is.na(Accesion)) %>%
mutate(valor = 1L) %>%
select(Accesion, marcador_probable, valor) %>%
distinct(Accesion, marcador_probable, .keep_all = TRUE) %>%
pivot_wider(
id_cols    = Accesion,
names_from = marcador_probable,
values_from = valor,
values_fill = 0L,
values_fn  = max
) %>%
arrange(Accesion)
library(adegenet)
dependencies <- c("adegenet","ggplot2","hierfstat","poppr","corehunter","ape",
"pheatmap","edgeR","readr","reshape2","tidyr","polysat","dplyr")
if( !is.element("devtools",rownames(installed.packages() ) ) ){
install.packages("devtools")
install.packages("BiocManager")
}
library(devtools)
View(matriz_pa_ab)
View(matriz_pa_size)
source('Scripts/load_data.R', local = TRUE)
isrr5_1_18 <- load_data("Data/EXCEL_I5-1AL18.xlsx", c(1,10,21))
View(isrr5_1_18)
View(isrr5_1_18)
readxl::read_excel("Data/EXCEL_I5-1AL18.xlsx")
library(tidyverse)
source('Scripts/load_data.R', local = TRUE)
isrr5_1_18 <- load_data("Data/EXCEL_I5-1AL18.xlsx", c(1,10,21))
isrr5_19_35 <- load_data("Data/EXCEL_I5-19AL35.xlsx", c(1,10,20))
isrr5_36_52 <- load_data("Data/EXCEL_I5-36AL52.xlsx", c(1,10,20))
isrr5_53_69 <- load_data("Data/EXCEL_I5-53AL69.xlsx", c(1,10,20))
isrr5_70_86 <- load_data("Data/EXCEL_I5-70AL86.xlsx", c(1,10,20))
View(isrr5_1_18)
unique(isrr5_1_18$Accesion)
length(unique(isrr5_1_18$Accesion))
length(unique(isrr5_1_18$Accesion))
length(unique(isrr5_19_35$Accesion))
length(unique(isrr5_36_52$Accesion))
length(unique(isrr5_53_69$Accesion))
length(unique(isrr5_70_86$Accesion))
# x: vector numérico de tamaños (bp)
# gap_thr: diferencia mínima (en bp) para considerar que hay un cambio de grupo
find_breaks <- function(x, gap_thr = 40) {
xs   <- sort(na.omit(x))
gaps <- diff(xs)
# puntos donde el "salto" es grande
idx_big_gap <- which(gaps > gap_thr)
# punto medio entre los dos valores que forman el hueco
cut_points <- xs[idx_big_gap] + gaps[idx_big_gap] / 2
# extremos del rango + un pequeño margen
breaks <- c(min(xs) - 1, cut_points, max(xs) + 1)
breaks
}
length(unique(isrr5_1_18$Accesion)) +
length(unique(isrr5_19_35$Accesion)) +
length(unique(isrr5_36_52$Accesion)) +
length(unique(isrr5_53_69$Accesion)) +
length(unique(isrr5_70_86$Accesion)) +
length(unique(isrr5_1_18$Accesion)) +
length(unique(isrr5_19_35$Accesion)) +
length(unique(isrr5_36_52$Accesion)) +
length(unique(isrr5_53_69$Accesion)) +
length(unique(isrr5_70_86$Accesion))
View(isrr5_1_18)
issr5 <- cbind(isrr5_1_18,isrr5_19_35)
issr5 <- nbind(isrr5_1_18,isrr5_19_35)
issr5 <- rbind(isrr5_1_18,isrr5_19_35)
View(issr5)
issr5 <- rbind(isrr5_1_18,isrr5_19_35,isrr5_36_52)
View(issr5)
issr5 <- rbind(isrr5_1_18,isrr5_19_35,isrr5_36_52,isrr5_53_69)
issr5 <- rbind(isrr5_1_18,isrr5_19_35,isrr5_36_52,isrr5_53_69,isrr5_70_86)
View(issr5)
# x: vector numérico de tamaños (bp)
# gap_thr: diferencia mínima (en bp) para considerar que hay un cambio de grupo
find_breaks <- function(x, gap_thr = 40) {
xs   <- sort(na.omit(x))
gaps <- diff(xs)
# puntos donde el "salto" es grande
idx_big_gap <- which(gaps > gap_thr)
# punto medio entre los dos valores que forman el hueco
cut_points <- xs[idx_big_gap] + gaps[idx_big_gap] / 2
# extremos del rango + un pequeño margen
breaks <- c(min(xs) - 1, cut_points, max(xs) + 1)
breaks
}
# Puedes ajustar gap_thr según lo cerrado/abierto que quieras los grupos
breaks  <- find_breaks(issr5$Size_pb, gap_thr = 10)
centers <- (head(breaks, -1) + tail(breaks, -1)) / 2
# etiquetas de marcador, por ejemplo: M1_1576, M2_972, ...
labels <- paste0("ISSR5", "_", round(centers))
data_markers <- issr5 %>%
mutate(
marcador_probable = cut(
Size_pb,
breaks = breaks,
labels = labels,
include.lowest = TRUE
)
) %>%
# Clasificamos grosor relativo dentro de cada marcador:
# a = banda gruesa (>= mediana de grosor)
# b = banda delgada (< mediana de grosor)
group_by(marcador_probable) %>%
mutate(
umbral_grosor = median(Banda_tamanho, na.rm = TRUE),
tipo_banda    = if_else(Banda_tamanho >= umbral_grosor, "a", "b")
) %>%
ungroup() %>%
mutate(
marcador_ab = paste0(as.character(marcador_probable), "_", tipo_banda)
)
ggplot(data_markers, aes(x = Size_pb)) +
geom_histogram(bins = 60, fill = "grey70") +
geom_vline(xintercept = centers, linetype = 2) +
labs(x = "Base pairs (bp)", y = "Frecuencia") +
theme_minimal()
matriz_pa_ab <- data_markers %>%
filter(!is.na(marcador_ab), !is.na(Lane)) %>%
mutate(valor = 1L) %>%
select(Lane, marcador_ab, valor) %>%
distinct(Lane, marcador_ab, .keep_all = TRUE) %>%  # evitar duplicados exactos
pivot_wider(
id_cols    = Lane,
names_from = marcador_ab,
values_from = valor,
values_fill = 0L,
values_fn  = max   # 0 = ausencia, 1 = presente
) %>%
arrange(Lane)
# Matriz solo por tamaño (ignorando grosor):
matriz_pa_size <- data_markers %>%
filter(!is.na(marcador_probable), !is.na(Accesion)) %>%
mutate(valor = 1L) %>%
select(Accesion, marcador_probable, valor) %>%
distinct(Accesion, marcador_probable, .keep_all = TRUE) %>%
pivot_wider(
id_cols    = Accesion,
names_from = marcador_probable,
values_from = valor,
values_fill = 0L,
values_fn  = max
) %>%
arrange(Accesion)
View(matriz_pa_size)
View(isrr5_1_18)
sort(na.omit(x)
.
View(issr5)
View(issr5)
View(matriz_pa_size)
# x: vector numérico de tamaños (bp)
# gap_thr: diferencia mínima (en bp) para considerar que hay un cambio de grupo
find_breaks <- function(x, gap_thr = 30) {
xs   <- sort(na.omit(x))
gaps <- diff(xs)
# puntos donde el "salto" es grande
idx_big_gap <- which(gaps > gap_thr)
# punto medio entre los dos valores que forman el hueco
cut_points <- xs[idx_big_gap] + gaps[idx_big_gap] / 2
# extremos del rango + un pequeño margen
breaks <- c(min(xs) - 1, cut_points, max(xs) + 1)
breaks
}
# Puedes ajustar gap_thr según lo cerrado/abierto que quieras los grupos
breaks  <- find_breaks(issr5$Size_pb, gap_thr = 10)
centers <- (head(breaks, -1) + tail(breaks, -1)) / 2
# etiquetas de marcador, por ejemplo: M1_1576, M2_972, ...
labels <- paste0("ISSR5", "_", round(centers))
data_markers <- issr5 %>%
mutate(
marcador_probable = cut(
Size_pb,
breaks = breaks,
labels = labels,
include.lowest = TRUE
)
) %>%
# Clasificamos grosor relativo dentro de cada marcador:
# a = banda gruesa (>= mediana de grosor)
# b = banda delgada (< mediana de grosor)
group_by(marcador_probable) %>%
mutate(
umbral_grosor = median(Banda_tamanho, na.rm = TRUE),
tipo_banda    = if_else(Banda_tamanho >= umbral_grosor, "a", "b")
) %>%
ungroup() %>%
mutate(
marcador_ab = paste0(as.character(marcador_probable), "_", tipo_banda)
)
ggplot(data_markers, aes(x = Size_pb)) +
geom_histogram(bins = 60, fill = "grey70") +
geom_vline(xintercept = centers, linetype = 2) +
labs(x = "Base pairs (bp)", y = "Frecuencia") +
theme_minimal()
matriz_pa_ab <- data_markers %>%
filter(!is.na(marcador_ab), !is.na(Lane)) %>%
mutate(valor = 1L) %>%
select(Lane, marcador_ab, valor) %>%
distinct(Lane, marcador_ab, .keep_all = TRUE) %>%  # evitar duplicados exactos
pivot_wider(
id_cols    = Lane,
names_from = marcador_ab,
values_from = valor,
values_fill = 0L,
values_fn  = max   # 0 = ausencia, 1 = presente
) %>%
arrange(Lane)
# Matriz solo por tamaño (ignorando grosor):
matriz_pa_size <- data_markers %>%
filter(!is.na(marcador_probable), !is.na(Accesion)) %>%
mutate(valor = 1L) %>%
select(Accesion, marcador_probable, valor) %>%
distinct(Accesion, marcador_probable, .keep_all = TRUE) %>%
pivot_wider(
id_cols    = Accesion,
names_from = marcador_probable,
values_from = valor,
values_fill = 0L,
values_fn  = max
) %>%
arrange(Accesion)
View(matriz_pa_size)
# x: vector numérico de tamaños (bp)
# gap_thr: diferencia mínima (en bp) para considerar que hay un cambio de grupo
find_breaks <- function(x, gap_thr = 45) {
xs   <- sort(na.omit(x))
gaps <- diff(xs)
# puntos donde el "salto" es grande
idx_big_gap <- which(gaps > gap_thr)
# punto medio entre los dos valores que forman el hueco
cut_points <- xs[idx_big_gap] + gaps[idx_big_gap] / 2
# extremos del rango + un pequeño margen
breaks <- c(min(xs) - 1, cut_points, max(xs) + 1)
breaks
}
# Puedes ajustar gap_thr según lo cerrado/abierto que quieras los grupos
breaks  <- find_breaks(issr5$Size_pb, gap_thr = 10)
centers <- (head(breaks, -1) + tail(breaks, -1)) / 2
# etiquetas de marcador, por ejemplo: M1_1576, M2_972, ...
labels <- paste0("ISSR5", "_", round(centers))
data_markers <- issr5 %>%
mutate(
marcador_probable = cut(
Size_pb,
breaks = breaks,
labels = labels,
include.lowest = TRUE
)
) %>%
# Clasificamos grosor relativo dentro de cada marcador:
# a = banda gruesa (>= mediana de grosor)
# b = banda delgada (< mediana de grosor)
group_by(marcador_probable) %>%
mutate(
umbral_grosor = median(Banda_tamanho, na.rm = TRUE),
tipo_banda    = if_else(Banda_tamanho >= umbral_grosor, "a", "b")
) %>%
ungroup() %>%
mutate(
marcador_ab = paste0(as.character(marcador_probable), "_", tipo_banda)
)
ggplot(data_markers, aes(x = Size_pb)) +
geom_histogram(bins = 60, fill = "grey70") +
geom_vline(xintercept = centers, linetype = 2) +
labs(x = "Base pairs (bp)", y = "Frecuencia") +
theme_minimal()
matriz_pa_ab <- data_markers %>%
filter(!is.na(marcador_ab), !is.na(Lane)) %>%
mutate(valor = 1L) %>%
select(Lane, marcador_ab, valor) %>%
distinct(Lane, marcador_ab, .keep_all = TRUE) %>%  # evitar duplicados exactos
pivot_wider(
id_cols    = Lane,
names_from = marcador_ab,
values_from = valor,
values_fill = 0L,
values_fn  = max   # 0 = ausencia, 1 = presente
) %>%
arrange(Lane)
# Matriz solo por tamaño (ignorando grosor):
matriz_pa_size <- data_markers %>%
filter(!is.na(marcador_probable), !is.na(Accesion)) %>%
mutate(valor = 1L) %>%
select(Accesion, marcador_probable, valor) %>%
distinct(Accesion, marcador_probable, .keep_all = TRUE) %>%
pivot_wider(
id_cols    = Accesion,
names_from = marcador_probable,
values_from = valor,
values_fill = 0L,
values_fn  = max
) %>%
arrange(Accesion)
View(matriz_pa_size)
